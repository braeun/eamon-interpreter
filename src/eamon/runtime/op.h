/********************************************************************************
 *                                                                              *
 * EamonInterpreter - opcodes and code object                                   *
 *                                                                              *
 * modified: 2022-11-16                                                         *
 *                                                                              *
 ********************************************************************************
 * Copyright (C) Harald Braeuning                                               *
 ********************************************************************************
 * This file is part of EamonInterpreter.                                       *
 * EamonInterpreter is free software: you can redistribute it and/or modify it  *
 * under the terms of the GNU General Public License as published by the Free   *
 * Software Foundation, either version 3 of the License, or (at your option)    *
 * any later version.                                                           *
 * EamonInterpreter is distributed in the hope that it will be useful, but      *
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY   *
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for  *
 * more details.                                                                *
 * You should have received a copy of the GNU General Public License along with *
 * EamonInterpreter. If not, see <https://www.gnu.org/licenses/>.               *
 ********************************************************************************/

#ifndef OPCODE_H
#define OPCODE_H

#include "type.h"
#include "value.h"
#include <stdint.h>
#include <string>
#include <vector>


/*
 * List of op-codes
 */
/* No op: may be generated by parser but is ignored by assembler */
#define OP_NOP        0
/* main of function entry point: This is a non-executable op.
 * The following two words specifiy the memory size for numbers and strings. */
#define OP_ENTRY      1
/* push value to stack */
#define OP_PUSH       2
/* pop value from stack and discard it */
#define OP_POP        3
/* store value from stack in variable */
#define OP_STO        4
/* store value from stack in array variable by index */
#define OP_STOI       5
/* recall variable and push value to stack */
#define OP_RCL        6
/* recall value from array variable by index and push value to stack */
#define OP_RCLI       7
/* duplicate the value on top of the stack */
#define OP_DUP        8
/* swap the two values on top of the stack */
#define OP_SWAP       9
#define OP_ARIADD    16
#define OP_ARISUB    17
#define OP_ARIMUL    18
#define OP_ARIDIV    19
#define OP_ARIMOD    20
#define OP_CAST      21
#define OP_NEG       22
#define OP_INC       23
#define OP_DEC       24
#define OP_ARIEQ     25
#define OP_ARINE     26
#define OP_ARILE     27
#define OP_ARIGE     28
#define OP_ARILT     29
#define OP_ARIGT     30
#define OP_ARIAND    31 /* bitwise and */
#define OP_ARIOR     32 /* bitwise or */
#define OP_ARINOT    33
#define OP_OR        34 /* logic or */
#define OP_AND       35 /* logic and */
#define OP_JSR       48 /* push the next addess on the stack and jump to an address */
#define OP_RET       49 /* pop the next address from the stack and jump to it */
#define OP_JZ        50
#define OP_JUMP      51
#define OP_JNZ       52
#define OP_CALL      55 /* library call */
#define OP_FOR       56
#define OP_NEXT      57
#define OP_RSZ       64
#define OP_CLR       65
#define OP_ERRHDL    66
#define OP_END      127

/* Meta codes */
#define ASM_LINE  255


class COp;

typedef std::vector<COp> Code;

/** @brief Op-Code
 *
 * This class represents a high level description of a single op code
 */
class COp {
 public:
  COp(int32_t mnemonic=OP_END, Type type=Type::undefinedType);
  ~COp(void);

  /**
   * @brief Gets the full opcde
   * @return the full opcode
   */
  uint32_t getOpCode() const;

  /** Return mnemonic code */
  int32_t getMnemonic() const;

  /**
   * @brief Gets the label associated with this op
   * @return the label or 0 if no label is associated
   */
  int32_t getLabel() const;

  /**
   * @brief Sets the label associated with the op
   * @param l the label
   */
  void setLabel(int32_t l);

  Type getType() const;

  Type getParameterType() const;

  void setParameter(int32_t v);

  void setParameter(double v);

  void setParameter(const std::string& v);

  void setParameter(const std::vector<Value>& v, Type t);

  int32_t getParameterInt32() const;

  double getParameterDouble() const;

  std::string getParameterString() const;

  const std::vector<Value>& getParameterArray() const;

  /** Return true if op codes are equal */
  int operator==(int32_t n);
  /** Return true if op codes are not equal */
  int operator!=(int32_t n);

  /**
   * @brief getMnemonic
   * @param op the 32bit op code
   * @return the mnemonic part
   */
  static uint32_t getMnemonic(uint32_t op);
  /**
   * @brief Get the type on which this op code acts.
   * @param op the 32bit op code
   * @return the type
   */
  static Type getType(uint32_t op);

 private:
  int32_t label;      /**< if >0 this op code has a label */
  int32_t mnemonic;   /**< mnemonic */
//  uint32_t varg;      /**< argument specifies a variable / function */
  Type type;
  Type parType;
  union {
    int32_t i32;
    double d;
  };
  std::string s;
  std::vector<Value> a;
};

/** @brief Code block
 *
 * This class represents a code block
 */
class CodeBlock {
 public:
  ~CodeBlock(void);

  /** Return pointer to the code in the block */
  Code* getCodePtr(void);

  /** Return pointer to the code in the block */
  const Code* getCodePtr(void) const;

  /** Return name of the code block */
  std::string getName(void) const;

  std::string name;
  Code code;
};

#endif
